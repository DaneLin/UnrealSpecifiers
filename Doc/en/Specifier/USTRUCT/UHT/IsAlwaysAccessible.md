# IsAlwaysAccessible

- **Function Description:** Ensures that the declaration of the specified structure is always accessible when UHT generates files, otherwise a mirrored structure definition must be created in gen.cpp
- **Metadata Type:** bool
- **Engine Module:** UHT
- **Restriction Type:** Exclusive to NoExportTypes.h for UHT usage
- **Usage Frequency:** 0

Indicates whether the declaration of this structure is always accessible in the gen.cpp file generated by UHT for NoExportTypes.h.

In other words, it determines if these structures are declared within GeneratedCppIncludes.h. If not found, a mirrored structure definition must be manually created when generating similar constructs like Z_Construct_UScriptStruct_FMatrix44dStatics. If found, such as FGuid, no additional definition is needed.

Thus, this is a manual internal marker, aiding the UHT program in identifying which structures require mirrored structure definitions.

When examining structures in NoExportTypes.h, some structures (85/135) are marked with IsAlwaysAccessible, while others are not. This is because when UHT generates gen.cpp for NoExportTypes.h,

```cpp
\UnrealEngine\Engine\Source\Runtime\CoreUObject\Public\UObject\GeneratedCppIncludes.h
#include "UObject/Object.h"
#include "UObject/UObjectGlobals.h"
#include "UObject/CoreNative.h"
#include "UObject/Class.h"
#include "UObject/MetaData.h"
#include "UObject/UnrealType.h"
#include "UObject/EnumProperty.h"
#include "UObject/TextProperty.h"
#include "UObject/FieldPathProperty.h"

#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2
#include "CoreMinimal.h"
#endif

\Hello\Intermediate\Build\Win64\HelloEditor\Inc\CoreUObject\UHT\NoExportTypes.gen.cppï¼š
// Copyright Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

//The following two lines:
#include "UObject/GeneratedCppIncludes.h"//A
#include "UObject/NoExportTypes.h"//B
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeNoExportTypes() {}
```

If the struct definition can be found directly in the first two included headers, no additional definition is needed at points A and B in gen.cpp where the structure is required.

```cpp
const UECodeGen_Private::FStructParams Z_Construct_UScriptStruct_FMatrix44f_Statics::ReturnStructParams = {
		(UObject* (*)())Z_Construct_UPackage__Script_CoreUObject,
		nullptr,
		nullptr,
		"Matrix44f",
		Z_Construct_UScriptStruct_FMatrix44f_Statics::PropPointers,
		UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FMatrix44f_Statics::PropPointers),
		sizeof(FMatrix44f),//Location A
		alignof(FMatrix44f),//Location B
		RF_Public|RF_Transient|RF_MarkAsNative,
		EStructFlags(0x00000038),
		METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FMatrix44f_Statics::Struct_MetaDataParams), Z_Construct_UScriptStruct_FMatrix44f_Statics::Struct_MetaDataParams)
	};
```

If the definition is not found, for example, FMatrix44f, which is defined in Engine\Source\Runtime\Core\Public\Math\Matrix.h, an identical definition must be generated for it (omitting includes to speed up compilation):

```cpp
struct Z_Construct_UScriptStruct_FMatrix44f_Statics
	{
		struct FMatrix44f //A definition with a consistent memory layout
		{
			FPlane4f XPlane;
			FPlane4f YPlane;
			FPlane4f ZPlane;
			FPlane4f WPlane;
		};

		static_assert(sizeof(FMatrix44f) < MAX_uint16);
		static_assert(alignof(FMatrix44f) < MAX_uint8);
```

Of course, if the definitions of subfields or parent classes are also not found, only the parent definition needs to be written first. Therefore, FindNoExportStructsRecursive in cs is used to identify related structures. The absence of the IsAlwaysAccessible flag indicates that a dummy structure definition will be generated

```cpp
private static void FindNoExportStructsRecursive(List<UhtScriptStruct> outScriptStructs, UhtStruct structObj)
		{
			for (UhtStruct? current = structObj; current != null; current = current.SuperStruct)
			{
				// Is isn't true for noexport structs
				if (current is UhtScriptStruct scriptStruct)
				{
					if (scriptStruct.ScriptStructFlags.HasAnyFlags(EStructFlags.Native))
					{
						break;
					}

					// these are a special cases that already exists and if wrong if exported naively
					if (!scriptStruct.IsAlwaysAccessible)
					{
						outScriptStructs.Remove(scriptStruct);
						outScriptStructs.Add(scriptStruct);
					}
				}

				foreach (UhtType type in current.Children)
				{
					if (type is UhtProperty property)
					{
						foreach (UhtType referenceType in property.EnumerateReferencedTypes())
						{
							if (referenceType is UhtScriptStruct propertyScriptStruct)
							{
								FindNoExportStructsRecursive(outScriptStructs, propertyScriptStruct);
							}
						}
					}
				}
			}
		}
```