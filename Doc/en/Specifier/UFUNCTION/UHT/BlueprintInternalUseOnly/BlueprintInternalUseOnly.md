# BlueprintInternalUseOnly

- **Function Description:** Indicates that this function should not be disclosed to end users. It is called internally within blueprints and not exposed to users.

- **Metadata Type:** bool
- **Engine Module:** Blueprint, UHT
- **Functionality Mechanism:** Adds [BlueprintInternalUseOnly](../../../../Meta/Blueprint/BlueprintInternalUseOnly.md) and [BlueprintType](../../../../Meta/Blueprint/BlueprintType.md) to the Meta section
- **Commonality:** ★★★

Indicates that this function should not be disclosed to end users. It is called internally within blueprints and not exposed to users.

Equivalent to setting BlueprintInternalUseOnly = true in the meta. By default, functions marked as BlueprintCallable/Pure generate UK2Node_CallFunction for invocation. However, BlueprintInternalUseOnly prevents this from occurring.

There are two typical use cases:

Firstly, to hide the function within blueprints, while still allowing it to be invoked reflectively by name due to its UFUNCTION attribute. Although this usage is rare, it is still considered a valid application.

Secondly, the engine may declare another blueprint function node elsewhere for this function, following specific rules, which necessitates hiding the one created by default rules.

## Sample Code 1:

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Internal :public AActor
{
public:
	GENERATED_BODY()
public:
	//(BlueprintInternalUseOnly = true, BlueprintType = true, ModuleRelativePath = Function/MyFunction_Internal.h)
	//FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable
	UFUNCTION(BlueprintCallable, BlueprintInternalUseOnly)
	void MyFunc_InternalOnly() {}

	//FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable
	UFUNCTION(BlueprintCallable)
	void MyFunc_Default() {}
};
```

Only MyFunc_Default is callable within blueprints. This implies that the function is still exposed to blueprints but is hidden from direct user invocation, yet can be called indirectly through function name lookup in the code.

![Untitled](Untitled.png)

An example is found in the source code, where the GetLevelScriptActor function is not callable from blueprints but can be located by name, facilitating the generation of a UFunction to be injected elsewhere as a callback

```cpp
ULevelStreaming:
UFUNCTION(BlueprintPure, meta = (BlueprintInternalUseOnly = "true"))
ENGINE_API ALevelScriptActor* GetLevelScriptActor();

然后发现：
GetLevelScriptActorNode->SetFromFunction(ULevelStreaming::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(ULevelStreaming, GetLevelScriptActor)));
```

## Sample Code 2:

The implementation code is not provided here; you can refer to it in the project.

```cpp
UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject,HasDedicatedAsyncNode))
class INSIDER_API UMyFunction_Async :public UCancellableAsyncAction
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintAssignable)
	FDelayOutputPin Loop;

	UPROPERTY(BlueprintAssignable)
	FDelayOutputPin Complete;

	UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true", WorldContext = "WorldContextObject"), Category = "Flow Control")
	static UMyFunction_Async* DelayLoop(const UObject* WorldContextObject, const float DelayInSeconds, const int Iterations);

	virtual void Activate() override;

	UFUNCTION()
	static void Test();
private:
	const UObject* WorldContextObject = nullptr;
	float MyDelay = 0.f;
	int MyIterations = 0;
	bool Active = false;

	UFUNCTION()
	void ExecuteLoop();

	UFUNCTION()
	void ExecuteComplete();
};

```

## Example Effect:

If the BlueprintInternalUseOnly attribute is commented out in the source code, two DelayLoop nodes will appear in the blueprint. The first one is generated according to UBlueprintAsyncActionBase rules, and the second one is generated according to regular blueprint function rules. Clearly, we do not want to present both to the user, causing confusion. Thus, BlueprintInternalUseOnly must be added to prevent the creation of the default blueprint node.

![Untitled](Untitled%201.png)

## Principle:

Regarding the use of UBlueprintAsyncActionBase, the function implementation in UK2Node_BaseAsyncTask reflects the rules for writing classes derived from UBlueprintAsyncActionBase. In essence, it uses a static function as a factory function and analyzes the Delegate property of this Proxy class as a Pin.

If BlueprintInternalUseOnly is not set to "true," two functions will be generated. The one below is the generation of an ordinary static function, while the one above is generated by analyzing UBlueprintAsyncActionBase.

Among them, the process of identifying static function as FactoryFunction in UBlueprintAsyncActionBase is, BlueprintActionDatabaseImpl::GetNodeSpecificActions will trigger UK2Node_AsyncAction::GetMenuActions , so ActionRegistrar.RegisterClassFactoryActions , the internal judgment RegisterClassFactoryActions_Utils::IsFactoryMethod ( Function UBlueprintAsyncActionBase ) will pass (the judgment is a static function, and the return type is a subclass object of UBlueprintAsyncActionBase ), and then continue Create a factory method of nodeSpawner via callback UBlueprintFunctionNodeSpawner::Create ( FactoryFunc ) ; .

In summary, at this point, BlueprintInternalUseOnly serves to hide the node generated by default.