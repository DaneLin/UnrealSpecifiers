#GetByRef

- **Function Description:** Instructs UHT to generate C++ code that returns a reference for this attribute
- **Usage Location:** UPROPERTY
- **Engine Module:** UHT
- **Metadata Type:** bool
- **Restriction:** Applicable only to attributes within structures specified by SparseClassDataTypes.
- **Associated Items:** [SparseClassDataTypes](SparseClassDataTypes.md)

Indicates that UHT should generate C++ code that returns a reference for this attribute.

Applicable only to attributes within structures specified by SparseClassDataTypes.

## Code Example:

```cpp
USTRUCT(BlueprintType)
struct FMySparseClassData
{
	GENERATED_BODY()

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FString MyString_EditDefault = TEXT("MyName");
	//FString GetMyString_EditDefault() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault; } \

	// "GetByRef" means that Blueprint graphs access a const ref instead of a copy.
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (GetByRef))
	FString MyString_EditDefault_ReadOnly = TEXT("MyName");
	//const FString& GetMyString_EditDefault_ReadOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault_ReadOnly; }
};

UCLASS(Blueprintable, BlueprintType, SparseClassDataTypes = MySparseClassData)
class INSIDER_API AMyActor_SparseClassDataTypes :public AActor
{
	GENERATED_BODY()
}
```

## Generated Code:

It can be seen that the return value generated by the latter is const FString& instead of FString .

```cpp
#define FID_Hello_Source_Insider_Class_Trait_MyClass_SparseClassDataTypes_h_36_SPARSE_DATA_PROPERTY_ACCESSORS \
FString GetMyString_EditDefault() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault; } \
const FString& GetMyString_EditDefault_ReadOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault_ReadOnly; }
```

## Principle:

When generating code for SparseDataType in UHT, GetByRef will be judged to generate different format codes respectively.

```cpp
private StringBuilder AppendSparseDeclarations(StringBuilder builder, UhtClass classObj, IEnumerable<UhtScriptStruct> sparseScriptStructs, UhtUsedDefineScopes<UhtProperty> sparseProperties)
{
	if (property.MetaData.ContainsKey(UhtNames.GetByRef))
	{
				builder.Append("const ").AppendSparse(property).Append("& Get").Append(cleanPropertyName).Append("() const");
	}
	else
	{
				builder.AppendSparse(property).Append(" Get").Append(cleanPropertyName).Append("() const");
	}
}
```